\documentclass{article}
\author{Kevin R. Thornton}
\title{Policies in \texttt{fwdpp}}
\usepackage{fullpage}
\usepackage{listings}
\usepackage{url}
\usepackage{color}
\usepackage{hyperref}

\hypersetup{
colorlinks=true,
    linkcolor=blue,          % color of internal links (change box color with linkbordercolor)
    citecolor=blue,        % color of links to bibliography
    filecolor=blue,      % color of file links
    urlcolor=blue           % color of external links
}

\lstset { %
    language=C++,
    tabsize=4,
%    backgroundcolor=\color{red}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}
\begin{document}
\maketitle
\tableofcontents

\newpage

\section{Introduction}
This document is intended to be an in-depth discussion of policies and their role in implementing forward-time population genetic simulations using the C++ template library \texttt{fwdpp}.  We will first describe what policies are using standard C++ examples, and then we will get into the harder stuff.

An understanding of C++ fundamentals, including containers, their iterators, and how they relate to the standard algorithms, is assumed knowledge here.

\section{Policies in C++}
\subsection{Policies are everywhere}
Policies are a part of every programming language.  Generally-speaking, they modify the behavior of what functions are with (or to) data.  In other words, they turn a generic function into a piece of code doing a specific task.  Let's start with the rather trivial example of sorting a vector:

\begin{lstlisting}
#include <algorithm>
#include <vector>

using namespace std;

int main ( int argc, char ** argv )
{
  vector<unsigned> vu;

  //fill vu with data
  for( unsigned i = 10 ; i > 1 ; --i )
  {
    vu.push_back(i);
  }

  sort(vu.begin(),vu.end());
}
\end{lstlisting}

The above example is 100\% standard C++.  But what is going on under the hood of the sort function is quite interesting.  A bubble sort algorithm is being executed, and the values are being compared via a call to this function:
\begin{lstlisting}
  template <class T> struct less : binary_function <T,T,bool> {
    //algorithms can't guess return types,
    //and therefore often need this typedef
    typedef bool result_type;
    bool operator() (const T& x, const T& y) const {return x<y;}
  };
\end{lstlisting}

\subsection{Policies are often function objects}
The structure called less is a ``function object'', and is the policy being employed in the bubble sort.  Further, is a template, meaning it works on any data type for which operator$<$ is defined.  The detail that less inherits from binary\_function is important for how it plugs into the sort algorithm, but we'll deal with those issues later.

The way such a function object is used looks like:
\begin{lstlisting}
  int x = 5, y = 6;
  /*
  The less() instantiates a (temporary) object of type less<T>,
  where T = int in this case.
  the (x,y) passes those to variables to the operator() of less.
  (This is where the term
  ``function object'', or functor for short, comes from.)
  */
  bool x_is_less = less()(x,y);
\end{lstlisting}

\subsection{Policies change behavior of algorithms}
OK, so now we hopefully have a basic understanding of what a policy is and that algorithms in C++ work through policies implemented as function objects.  This lets us change the behavior of algorithms:
\begin{lstlisting}
  #include <functional> //need this header for std::greater<T>
  //Sort in descending order (biggest values @ front of vu after sort)
  sort( vu.begin(), vu.end(), greater<int>() );
\end{lstlisting}
Same bubble sort, different outcome because of different policy.

\subsection{Binding extends what policies can do}
We can further modify the behavior of policies by sending additional arguments along with the policy as it goes to the algorithm.  This is called binding an argument to a function call. For example, let's find the first value in our vector that is $\geq 5$:
\begin{lstlisting}
  //we need these headers
  #include <functional>
  #include <iostream>

  vector<unsigned>::iterator itr = find_if( vu.begin(), 
  vu.end(), 
  bind2nd( greater_equal<int>(), 5 ) );

  //print out the value pointed to by the iterator, 
  //if and only if we found something.  In C++,
  //when a policy never finds anything, 
  //the end of the container is returned by tradition
  if( itr != vu.end() )
  {
    cout << *itr << '\n';
  }
\end{lstlisting}

The find\_if algorithm takes each value in the range and evaluates it via the policy.  Here, the policy is greater\_equal, which takes two arguments.  The second argument is provided by using the standard-library function bind2nd, which results in the value 5 being the second value passed to the policy's operator().  The standard binders are OK, but the ones in the boost (\url{http://www.boost.org}) libraries are far superior:

\begin{lstlisting}
  //we need these headers
  #include <functional>
  #include <iostream>
  #include <boost/bind.hpp>

  vector<unsigned>::iterator itr = find_if( vu.begin(), 
  vu.end(), 
  //here, _1 is a placeholder for a value that the algorithm must provide
  boost::bind( greater_equal<int>(),_1, 5 ) );

  //print out the value pointed to by the iterator, 
  //if and only if we found something.  In C++,
  //when a policy never finds anything, 
  //the end of the container is returned by tradition
  if( itr != vu.end() )
  {
    cout << *itr << '\n';
  }
\end{lstlisting}

The boost binders are preferred because they can send up to 9 variables (some, all, or none being placeholders) to algorithms.  They're just easier to work with, too.  The only downside is needing boost installed, but if you're using C++, you need boost anyways, because you need the binders.  Circular logic FTW!

\subsection{Summary so far}
\begin{enumerate}
\item Policies change how algorithms behave
\item Policies are often templates
\item Policies are often function objects
\item Policies + binders + algorithms = a reusable code base that can do lots of different (and often quite complicated) things when the right policy is written.
\item Policies can often be quite short to implement (see the definition of less above).  This doesn't have to be the case, but it often works out that way in practice.
\end{enumerate}

\section{Algorithms in \texttt{fwdpp}}
For individual-based simulations, the primary algorithms are sample\_diploid and remove\_lost and/or remove\_fixed\_lost.  For gamete-baesd simulations, additional algorithms include the functions mutate, recombine, and migrate (and/or migrate\_from\_to).  All of these functions are in the name space \texttt{KTfwd} and are documented both in the source code, via the doxygen output based on the source code, and finally in the example code that comes with the library.

Some of the code in some of these algorithms is quite complex, largely because generic templates can have hideous syntax.  You should't have to worry about that unless you like seeing how the sausage is made.  Most users of \texttt{fwdpp} will be writing custom policies to stick into these algorithms and will likely be starting from the examples in order to get oriented.  For them, the necessary information is to understand what is required of a policy.  That is the subject of the remainder of this document.

\section{Policy requirements in \texttt{fwdpp}}
This section discusses the requirements placed on policies in \texttt{fwdpp}.  These requirements are essentially standards placed on data types in order to ensure that simulations behave properly. (Note that ``behave properly'' is not the same as ``are implemented correctly''!  It is totally possible to have a simulation that compiles with no warnings and runs without crashing but is not the model you had in mind.)  The policy requirements are enforced during compilation, such that a nonconforming policy cannot result in a compiled simulation program.

In the following sections, we will discuss policy requirements, how the built-in policies work, and also create some new policies.  We'll build some policies for a simple quantitative trait with selection simulation, and later on combine them all to see how sample\_diploid would actually be called (for the case of a constant-sized population in an individual-based simulation).  For additional and more complex examples, see the code for the example programs that come with the library.

\subsection{Mutation policies}
This is the mutation base class  provided by \texttt{fwdpp}
\begin{lstlisting}
  /*! \brief Base class for mutations
    At minimum, a mutation must contain a position and a count in the population.	
    You can derive from this class, for instance to add selection coefficients,
    counts in different sexes, etc.
  */
  struct KTfwd::mutation_base
  {
    /// Mutation position
    mutable double pos;
    /// Count of mutation in the population
    unsigned n;
    /// Is the mutation neutral or not?
    bool neutral;
    /// Used internally (don't worry about it for now...)
    bool checked;
    mutation_base(const double & position, 
    const unsigned & count, const bool & isneutral = true)
      : pos(position),n(count),neutral(isneutral),checked(false)
    {	
    }
    virtual ~mutation_base(){}
};
\end{lstlisting}

The above code defines a mutation as something with a position (stored as a double), a count (unsigned integer), a boolean declaring the mutation to be neutral or not, and another boolean called ``checked'' which is very important but should only be directly manipulated by internal library functions (unless you really geek out and see what the internals are doing.  In that case--go nuts.)

The mutation base class is not sufficient for any interesting sorts of simulations.  Rather, one must derive a class from it with more data types.  The library provides a class called mutation, which is probably the standard type of mutation that a population geneticist would think of (this class is also in the library's namespace KTfwd):

\begin{lstlisting}
  struct mutation : public mutation_base
  //!The simplest mutation type, adding just a selection 
  //coefficient and dominance to the interface
  {
    /// selection coefficient
    mutable double s;
    /// dominance coefficient
    mutable double h;
    mutation( const double & position, const double & sel_coeff,const unsigned & count,
	      const double & dominance = 0.5) 
      : mutation_base(position,count,(sel_coeff==0)),s(sel_coeff),h(dominance)
    {
    }
    bool operator==(const mutation & rhs) const
    {
      return( fabs(this->pos-rhs.pos) <= std::numeric_limits<double>::epsilon() &&
	      this->s == rhs.s );
    }
};
\end{lstlisting}

What does a mutation policy (model) need to do?  \textbf{The answer is that a single call to the mutation model function (or function object) must return a single instance of the simulation's mutation type with a count of 1.}

\subsubsection{Example: the infinitely-many sites model of mutation}
This mutation model states that a new mutation occurs at a site not currently segregatig in the population.  This statement implies the following:
\begin{enumerate}
\item We need a method to rapidly choose mutation positions that don't currently exist in the (meta-)population.
\item Each gamete containing a new mutation is by definition a new gamete in the (meta-)population.  If we did \#1 correctly, then the newly-mutated gamete differs from all others in the population by at least 1 new mutation.
\end{enumerate}

We will now implement this mutation model for the mutation type ``mutation'' defined above.  In order to add some complexity to our mutation model, we will make the additional modeling assumptions:
\begin{enumerate}
\item Mutation positions are continuous on the interval $[0,1)$.
\item Neutral mutations arise at rate $\mu$ per gamete per generation
\item Selected mutations arise at rate $\mu_s$ per gamete per generation.
\item The selection coefficient for a newly-arising mutation is exponentially-distributed with mean $s_m$.  Further, half the time, selected mutations are deleterious ($s < 0$).  Otherwise, they are beneficial ($s > 0$).
\item Dominance will be uniform from 0 to 2.  (We'll be scaling fitness as $1, 1+hs, 1+2s$ for genotypes AA, Aa, and aa, respectively.)
\end{enumerate}

From a programming point of view, we need a means to lookup all mutation positions currently segregating in the population.  \texttt{fwdpp} provides support for lookup tables that conform to the behavior of the type \texttt{std::map}.  While one could use a type like 
\begin{lstlisting}
  std::map<double,bool>
\end{lstlisting}
it is more efficient to use a hash table like 
\begin{lstlisting}
  #include <boost/unordered_set.hpp> //need this header
  typedef boost::unordered_set<double,boost::hash<double>,KTfwd::equal_eps > lookup_table_type;
\end{lstlisting}

The above code creates a new data type called ``lookup\_table\_type'' that hashes doubles with the data type KTfwd::equal\_eps as its comparison operator.  That comparison operation is provided by the library and looks like this:
\begin{lstlisting}
  struct equal_eps
  {
    typedef bool result_type;
    template<typename T>
    inline bool operator()(const T & lhs, const T & rhs) const
    {
      return( std::max(lhs,rhs)-std::min(lhs,rhs) <= std::numeric_limits<T>::epsilon() );
    }
  };
\end{lstlisting}

Note that you could provide your own equality comparison policy for the hashing table.  This one would be excellent, and should be included int the library in future versions as it may be the most robust:
\begin{lstlisting}
  struct equality_comparison_strict
  {
    typedef bool result_type;
    template<typename T>
    inline bool operator()(const T & lhs, const T & rhs) const
    {
      return( !(lhs > rhs) && !(lhs < rhs) );
    }
  };
\end{lstlisting}

We can now completely define our mutation model as a function (we could do it as a function object, too).  We assume that we are using the boost list type and boost's memory pool allocator:

\begin{lstlisting}
  typedef KTfwd::mutation mtype;
  typedef boost::pool_allocator<mtype> mut_allocator;
  typedef boost::container::list<mtype,mut_allocator > mlist;
  mtype mutmodel( gsl_rng * r, mlist * mutations,
                  const double & mu_neutral,
                  const double & mu_selected,
                  const double & mean_s,
                  lookup_table_type * lookup )
    {
      //get new mutation position
      double pos = gsl_rng_uniform(r);
      //this is very rapid lookup...
      while( lookup->find(pos) != lookup->end() )
      {
        pos = gsl_rng_uniform(r);
      }
      //ok, we have new position, so put it in lookup table
      lookup->insert(pos);

      //law of TTL prob
      bool neutral = (gsl_rng_uniform(r) <= (mu_neutral)/(mu_neutral+mu_selected)) ? true : false;

      //return neutral mutation
      if ( neutral ) { return mtype(pos,0,1,0); }

      //get selection coefficient
      double s = gsl_ran_exponential(r,mean_s);
      if( gsl_ran_uniform(r) <= 0.5 ) { s = -1.*s; }

      //the gsl_ran_flat call generates the dominance
      return mtype(pos,s,1,gsl_ran_flat(r,0.,2.));
    }
\end{lstlisting}

That is is--the mutation model is complete.  We still need to deal with how mutations are entered into data structures representing the population, but we'll treat that later.

The mutation policy is passed to any of the various sample\_diploid functions in the library like this:

\begin{lstlisting}
  boost::bind(mutmodel,r,&mutations,
              mu_neutral, mu_selected,
              mean_s, &lookup);
\end{lstlisting}

Note that several of the data types passed to the model are non-const pointers.  Therefore, it is very likely that the data pointed to will be modified my the mutation model!

\subsubsection{A model for quantitative trait simulations}
Let's define a model where a mutation affecting fitness does so via its effect size, $e$, which is Gaussian-distributed with mean zero and standard deviation $\sigma_e$.

We need a mutation class:
\begin{lstlisting}
  struct mut_e : public KTfwd::mutation_base
  {
    double e;
    mut_e( const double & __pos,
           const unsigned & __n,
           const bool & __neut,
           const double & __e ) : KTfwd::mutation_base(__pos,__n,__neut),e(__e)
           {
           }
  };

 typedef mut_e mtype;
\end{lstlisting}

OK, our mutation model is going to be the following.  It is infinitely-many sites with both neutral and non-neutral mutations:
\begin{lstlisting}
   typedef KTfwd::mutation mtype;
   typedef boost::pool_allocator<mtype> mut_allocator;
   typedef boost::container::list<mtype,mut_allocator > mlist;
   mtype mutmodel_Qtrait( gsl_rng * r, mlist * mutations,
                          const double & mu_neutral,
                          const double & mu_selected,
                          const double & sigma_e,
                          lookup_table_type * lookup )
    {
      //get new mutation position
      double pos = gsl_rng_uniform(r);
      //this is very rapid lookup...
      while( lookup->find(pos) != lookup->end() )
      {
        pos = gsl_rng_uniform(r);
      }
      //ok, we have new position, so put it in lookup table
      lookup->insert(pos);

      //law of TTL prob
      bool neutral = (gsl_rng_uniform(r) <= (mu_neutral)/(mu_neutral+mu_selected)) ? true : false;

      //return neutral mutation
      if ( neutral ) { return mtype(pos,1,true,0); }

      //the gsl_ran_gaussian call determines the effect size
      return mtype(pos,1,gsl_ran_gaussian(r,sigma_e),false);
    }
\end{lstlisting}

\subsection{Recombination}
\subsubsection{\label{recmodel}How recombination is modeled in \texttt{fwdpp}}
Poisson number of crossovers.  Returns either unchanged gametes or new gametes with frequencies of 1.

\subsubsection{Recombination map functions}
In \texttt{fwdpp}, a recombination map is a function or function object that returns a double and takes no additional arguments from the algorithm.  The return value is the position of the crossing over event.  The simplest recombination map is uniform.  Here is how to implement such a map on the interval $[0,1)$:

\begin{lstlisting}
  #include <boost/function.hpp>
  #include <boost/bind.hpp>
  #include <gsl/gls_rng.h>
  //gsl_rng * r assumed to be initialized already...
  boost::function< double(void) > recmap = boost::bind( gsl_rng_uniform, r);
\end{lstlisting}

Let us write a recombination map function that models a strong hotspot of crossing over.  The positions will still be on the interval $[0,1)$.  A fraction $p$ of the recombination events will come from a uniform distribution and $1-p$ will come from a beta distribution with parameters $a$ and $b$.  The genetic map looks like this:
\begin{lstlisting}
  double mixture_map(gsl_rng * r, 
                     const double & p,
                     const double & a,
                     const double & b)
      {
        return (gsl_rng_uniform(r) <= p) ? gsl_rng_uniform(r) : gsl_ran_beta(r,a,b);
      }
  /*
     This is a hot hotspot.  say hist( c(runif(1e3),rbeta(9e3,100,100) ) ) in R 
     to see density of crossover positions
  */
  boost::function< double(void) > recmap = boost::bind( mixture_map,r,0.1,100,100);
\end{lstlisting}

Either of the above code blocks results in a variable called recmap which is a function object representing a function call that takes no additional arguments and returns a double.  The variable recmap can be passed to the algorithm as the recombination (sometimes called genetic in the library documentation) map policy.

Note that the above policies were implemented by \textit{synthesiszing} a new function object type from a boost::bind operation via the boost::function template class.  You may synthesize all of your policies into variables this way, but it is not required.  However, the next subsection will reveal a case where it is required.

Note that gamete-based simulations only require this policy.

\subsubsection{Recombination model policy functions}
Individual-based simulations require a recombination model policy.  This policy is a function/function object that takes two non-const references to iterators to gametes as arguments and returns an unsigned integer representing the number of crossovers between the two gametes.  (Note that the return value will never been seen by a library user.  It basically exists to help debug things deeper in the library if and when it comes to that.)  

The library provides the policy \texttt{KTfwd::genetics101} which implements the model of crossing over described in Section \ref{recmodel}.  

The policy looks like this:
\begin{lstlisting}
  struct genetics101
  {
    typedef unsigned result_type;
    template<typename gamete_iterator_type,
             typename gamete_list_type_allocator,
             template<typename,typename> class gamete_list_type,
             typename rec_pos_generator>
    unsigned operator()( gamete_iterator_type & g1,
                         gamete_iterator_type & g2,
                         gamete_list_type< typename gamete_iterator_type::value_type,
                                           gamete_list_type_allocator > * gametes,
                                           const double & littler,
                                           gsl_rng * r,
                                           const rec_pos_generator & rp) const
       {
         typedef gamete_list_type< typename gamete_iterator_type::value_type, 
                                   gamete_list_type_allocator > glist_t;
         unsigned NREC = 0;
         if( g1 != g2 && gsl_rng_uniform(r) <= 0.5 )
         //then a non-parental type is inherited from p1 and p1 has two different gametes                                    
         {
           NREC += recombine_gametes(r,littler,gametes,g1,g2,rp,
           boost::bind(update_if_exists_insert<typename gamete_iterator_type::value_type,glist_t>,
           _1,gametes));
         }
         return NREC;
       }
     };
\end{lstlisting}

The main thing a library user needs to focus on is the argument list for \texttt{operator()}.  Specifically, it requires a variable of type rec\_pos\_generator which is stated in the documentation to be a recombination map policy. We pass this recombination model in an individual-based simulation to sample\_diploid like this:

\begin{lstlisting}
  boost::bind(KTfwd::genetics101(),  //the rec. model
             _1,_2,                  //placeholder for iterators to gametes
             &gametes,               //pointer to gamete list
             littler,                //Avg. # of crossovers b/w two gametes per region per generation
             r,                      //a gsl_rng *
             recmap)                 //A genetic map policy like the one we made above
\end{lstlisting}

\textbf{Important: if you try to pass something like boost::bind(gsl\_rng\_uniform,r) (to model a uniform genetic map) instead of a synthesized policy like the ``recmaps'' from above, your code is unlikely to compile.  Getting boost::binds to work within other boost::binds requires wizardry that is unlikely to be worth your time to learn.  (I've never bothered.)}
\subsection{Migration}
Migration policies are only used in individual-based simulations.  For gamete-based simulations, you may write a migration function (replacing \texttt{KTfwd::migrate}) that does what you need it to and is implemented in terms of \texttt{KTfwdd::migrate\_from\_to}.

For individual-based simulations involving a metapopulations, parent 1 comes from population $i$ and may or not be a migrant.  Parent two comes from population $j$ and $j = i$ in the case of no migration, otherwise $j \neq i$.  Migration policies may be the trickiest to write effectively because spatial models of migration can be complicated.  However, a migration policies requirements are simple.  \textbf{A migration policy is a function or function object taking an argument if type size\_t and returning a value of type size\_t.  The argument is the index of population $i$, and the return value is the index of population $j$.}

For example, let's assume two demes with migration rate $m$.  Here, $m$ is the probability that a parent is a migrant. This migration rate is equal between the two demes.  Because we are in a C-like language, the values allowed for the size\_t are $0 \leq i \leq 1$.  The migration policy is thus defined as follows:

\begin{lstlisting}
  size_t migpop(const size_t & source_pop, gsl_rng * r, const double & mig_prob)
  {
    //if parent is a migrant
    if( gsl_rng_uniform(r) <= mig_prob )
    {
      //return other population
      return ! source_pop;
    }
    //else, not a migrant
    return source_pop;
  }
\end{lstlisting}

And we pass it to sample\_diploid like this:
\begin{lstlisting}
  boost::bind(migpop, //the policy
              _1,     //placeholder for population index i
               r,     //gsl_rng *
               m)     //migration rate
\end{lstlisting}
\subsection{Fitness}
The ability to define custom fitness policies is perhaps the most useful feature of \texttt{fwdpp}.  Broadly-speaking, there are two typical types of fitness models used in population genetics.  The first are what I call site-based models, such as the model of multipicative fitness across sites.  In this standard model, each non-neutral site is effectively its own gene.  The second class are models are haplotype- or region- based, in that fitness depends on the effect sizes of the maternal and paternal haplotypes that a diploid inherited.  The library supports both types.  Haplotype-based fitness models are often efficient to compute, but site-based models can be done badly.  The library provides additional assistance for site-based models.

\textbf{A fitness policy is a function or function object taking two iterators pointing to gametes are arguments are returning a double.  The pointers are the diploid's haplotypes, and the return value is the fitness.}
\subsubsection{Site-dependent models of fitness}
The library provides a fitness policy called site\_dependent\_fitness.  This function object requires two additional policies defining what to do with homozygous sites and heterozygous sites.  The library provides the necessary policies in order to define a composite policy called multiplicative\_diploid:
\begin{lstlisting}
  //homozygote policy
  struct multiplicative_fitness_updater_hom
  {
    /*
    Works on interator to mutation that has
    a selection coefficient s
    */
    typedef void result_type;
    template<typename iterator_type>
    inline void operator()(double & fitness, const iterator_type & m1,const double & scaling = 2.) const
    {
      fitness *= ( 1. + scaling*m1->s );
    }
  };
  //heterozygote policy
  struct multiplicative_fitness_updater_het
  {
    /*
    Works on interator to mutation that has
    a selection coefficient s and 
    domeinance h
    */
    typedef void result_type;
    template<typename iterator_type>
    inline void operator()(double & fitness, const iterator_type & m1) const
    {
      fitness *= ( 1. + m1->s*m1->h );
    }
  };

  //now, the fitness policy itself
  struct multiplicative_diploid
  {
    typedef double result_type;
    template< typename iterator_type>
    inline double operator()(const iterator_type & g1, const iterator_type & g2,
                             const double scaling = 1.) const
    {
      return site_dependent_fitness()(g1,g2,
                                      boost::bind(multiplicative_fitness_updater_hom(),_1,_2,scaling),
                                      boost::bind(multiplicative_fitness_updater_het(),_1,_2),
                                      1.);
    }
  };
\end{lstlisting}

That last variable, scaling, means that fitness is the product of $1, 1+sh, 1+s \times scaling$ over sites.  This allows you to recreate results from the different parts of the literature that use $scaling = 1$ and 2.  Many classic results are based on a scaling of 2.

To use the multiplicative fitness policy in your simulations, this goes to sample\_diploid
\begin{lstlisting}
  boost::bind(multiplicative_diploid(),_1,_2,2.)
\end{lstlisting}

\subsubsection{Haplotype based fitness policies}
Here is one that assume a user-defined mutation type with effect size $e$ associated with it.  The effect of a haplotype is additive, the genetic model is recessive, and the phenotype is the genetic effect + a Gaussian random variable with standard deviation sigma.  Finally, fitnesses are under Gaussian stabilizing selection with a standard deviation of 1 and mean 0.

\begin{lstlisting}
struct hapfitness
{
  typedef result_type double;
  template<typename gam_itr
  double operator()(const gam_itr & g1,
                    const gam_itr & g2,
                    gsl_rng * r,
                    const double & sigmaE) const
   {
     double sum1=0.,sum2=0.;
     typedef typename gam_itr::value_type::mutation_container::const_iterator mci;
     for( mci mitr = g1.smutations.begin() ; mitr != g1.smutations.end() ; ++mitr )
     {
       //mitr is an iterator to an iterator!
       sum1 += (*mitr)->e;
     }
     for( mci mitr = g2.smutations.begin() ; mitr != g2.smutations.end() ; ++mitr )
     {
       //mitr is an iterator to an iterator!
       sum2 += (*mitr)->e;
     }

     //make sum1 be the value closest to 0
     if( fabs(sum1) > fabs(sum2) ) { std::swap(sum1,sum2); }

     //add noise to fitness
     //Using sum1 as the genetic part makes the model recessive
     double pheno = sum1 + gsl_ran_gaussian(r,sigmaE);
     
     /*
       Return fitnees under Gaussian stabilizing model.
       This is the only part of the Gaussian pdf that
       matters.  The rest is a constant
       and so won't affect sampling prop to fitness.
      */
     return std::exp( -std::pow(pheno,2) /2. );
   }
};
\end{lstlisting}

To use the above policy:
\begin{lstlisting}
  boost::bind( hapfitness(),
               _1,_2,
               r,sigmaE );
\end{lstlisting}

Please note that a long-running annoyance with open-source C++ compilers (GCC!) is whether or not exp, pow, log, etc., are in namespace std or in the global namespace.  This can vary from version to version and across operating systems.  Sometimes, you need to say \texttt{std::exp} when on another system that fails and you need \texttt{::exp}.

\subsection{Updating and removal policies}

\section{Putting it all togeter (kinda)}
Ok, once we have defined our mutation types, our containers, and our policies, a single generation of a constant-sized population in an individual-based simulation is evolved a follows:
\begin{lstlisting}
  double wbar = KTfwd::sample_diploid(r,
                                      &gametes,  //non-const pointer to gametes
                                      &diploids, //non-const pointer to diploids
                                      &mutations, //non-const pointer to mutations
                                      N,     //current pop size, remains constant
                                      mu,    //mutation rate per gamete
                                      /*
                                      The mutation model (defined above) will pass each gamete
      					 to be mutated to the mutation model function.  Again, _1
      					 is used as a placeholder for that gamete.
      				       */
      				       boost::bind(mutmodel_Qtrait,r,_1,mu_neutral,mu_selected,sigma_e,&lookup),
				       //The recombination policy includes the recombination map policy
      				       boost::bind(KTfwd::genetics101(),_1,_2,
						   &gametes,
      						   littler,
      						   r,
      						   recmap),
				       /*
					 Policy to insert new mutations at the end of the mutations list
				       */
      				       boost::bind(KTfwd::insert_at_end<mtype,mlist>,_1,_2),
				       /*
					 Policy telling KTfwd::mutate how to add mutated gametes into the gamete pool.
					 If mutation results in a new gamete, add that gamete to the 
					 end of gametes. This is always the case under infinitely-many sites,
					 but for other mutation models, mutation may result in a new
					 copy identical to an existing gamete.  If so,
					 that gamete's frequency increases by 1.
				       */
      				       boost::bind(KTfwd::insert_at_end<gtype,glist>,_1,_2),
      				       boost::bind(  boost::bind( hapfitness(),
                                                   _1,_2,
                                                   r,sigmaE ),
      				       /*
                                         Only remove lost mutations
      				       */
      				       boost::bind(KTfwd::mutation_remover(),_1,0));
          //Clean up the mutations list.  This also resets ``checked'' in each mutation to zero,
          //which is that ``internal detail'' referred to above
          //We don't removed fixed mutations b/c this is a quantitative trait simulation
      	  KTfwd::remove_fixed_lost(&mutations,&lookup,generation);
\end{lstlisting}
\end{document}
